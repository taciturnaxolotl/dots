{
  config,
  lib,
  pkgs,
  ...
}:

let
  cfg = config.atelier.services.knot-sync;
in
{
  options.atelier.services.knot-sync = {
    enable = lib.mkEnableOption "Knot to GitHub sync service";

    repoDir = lib.mkOption {
      type = lib.types.str;
      default = "/home/git/did:plc:krxbvxvis5skq7jj6eot23ul";
      description = "Directory containing git repositories";
    };

    githubUsername = lib.mkOption {
      type = lib.types.str;
      default = "taciturnaxolotl";
      description = "GitHub username";
    };

    secretsFile = lib.mkOption {
      type = lib.types.path;
      description = "Path to secrets file containing GITHUB_TOKEN";
    };

    logFile = lib.mkOption {
      type = lib.types.str;
      default = "/home/git/knot-sync.log";
      description = "Log file location";
    };

    interval = lib.mkOption {
      type = lib.types.str;
      default = "*/5 * * * *";
      description = "Cron schedule for sync (default: every 5 minutes)";
    };
  };

  config = lib.mkIf cfg.enable {
    systemd.services.knot-sync = {
      description = "Sync Knot repositories to GitHub";
      startLimitIntervalSec = 60;
      startLimitBurst = 10;
      serviceConfig = {
        Type = "oneshot";
        User = "git";
        EnvironmentFile = cfg.secretsFile;
        ExecStart = pkgs.writeShellScript "knot-sync" ''
          set -euo pipefail

          # Variables
          REPO_DIR="${cfg.repoDir}"
          GITHUB_USERNAME="${cfg.githubUsername}"
          LOG_FILE="${cfg.logFile}"

          # Log function
          log() { echo "$(date +'%Y-%m-%d %H:%M:%S'): $1" >> "$LOG_FILE"; }

          # Create the post-receive hook template
          # Use plain 'git' - it's in PATH via environment.systemPackages
          cat <<'HOOKEOF' > /tmp/post-receive.template
#!/usr/bin/env bash
# post-receive hook to sync to GitHub - AUTOGENERATED

# Load environment variables from secrets file
if [ -f "${cfg.secretsFile}" ]; then
  source "${cfg.secretsFile}"
fi

# Variables
GITHUB_USERNAME="${cfg.githubUsername}"
LOG_FILE="${cfg.logFile}"
REPO_NAME=$(basename $(pwd))

# Log function
log() { echo "$(date +'%Y-%m-%d %H:%M:%S'): $1" >> "''${LOG_FILE}"; }

# Check for nosync marker
if [ -f "$(pwd)/.nosync" ]; then
    log "Skipping sync for $REPO_NAME (nosync marker present)"
    exit 0
fi

# Function to sync to GitHub
sync_to_github() {
    log "Syncing $REPO_NAME to GitHub"
    expected_url="https://''${GITHUB_USERNAME}:''${GITHUB_TOKEN}@github.com/''${GITHUB_USERNAME}/''${REPO_NAME}.git"
    current_url=$(git remote get-url origin 2>/dev/null || echo "")

    if [ -z "$current_url" ]; then
        log "Adding origin remote"
        git remote add origin "$expected_url"
    elif [ "$current_url" != "$expected_url" ]; then
        log "Updating origin remote URL"
        git remote set-url origin "$expected_url"
    fi

    # Mirror push everything (refs, tags, branches)
    if git push --mirror origin 2>&1 | tee -a "''${LOG_FILE}"; then
        log "Sync succeeded for $REPO_NAME"
        return 0
    else
        log "Sync failed for $REPO_NAME"
        return 1
    fi
}

# Main
while read oldrev newrev refname; do
    log "Received push for ref '$refname' (old revision: $oldrev, new revision: $newrev)"
    sync_to_github
done
HOOKEOF

          HOOK_TEMPLATE="/tmp/post-receive.template"

          # Create or update the post-receive hook
          create_hook() {
            local new_repo_path="$1"
            local hook_path="$new_repo_path/hooks/post-receive.d/forward"
            local nosync_marker="$new_repo_path/.nosync"

            # Skip if .nosync marker exists
            if [ -f "$nosync_marker" ]; then
                log "Skipping $new_repo_path (nosync marker present)"
                return 0
            fi

            if [ -d "$new_repo_path" ]; then
                # Check that it's a git repository, specifically a bare repo
                if [ -f "$new_repo_path/config" ]; then
                    # Create hooks directory if it doesn't exist
                    mkdir -p "$(dirname "$hook_path")"
                    
                    # Check if hook is new or needs updating
                    local is_new=false
                    [ ! -f "$hook_path" ] && is_new=true
                    
                    # Always write the hook (they're autogenerated)
                    if cat "$HOOK_TEMPLATE" > "$hook_path" && chmod +x "$hook_path"; then
                      if [ "$is_new" = true ]; then
                        log "Created hook for $new_repo_path"
                        # Check if repo has any commits before pushing
                        if (cd "$new_repo_path" && git rev-parse HEAD >/dev/null 2>&1); then
                          # Auto push by simulating a post-receive hook trigger
                          log "Triggering initial push for $new_repo_path"
                          (cd "$new_repo_path" && \
                            echo "0000000000000000000000000000000000000000 $(git rev-parse HEAD) refs/heads/main" | \
                            "$hook_path")
                        fi
                      fi
                    else
                      log "Hook creation failed for $new_repo_path"
                    fi
                fi
            fi
          }

          # Keep track of hooks created
          hooks_created=0

          # Find all directories that look like bare Git repos without a post-receive hook
          ${pkgs.findutils}/bin/find "$REPO_DIR" -mindepth 1 -maxdepth 1 -type d \! -name ".*" -print0 |
            while IFS= read -r -d $'\0' repo_path; do
              create_hook "$repo_path"
              if [ $? -eq 0 ]; then
                hooks_created=$((hooks_created + 1))
              fi
          done

          # Only log completion if hooks were actually created
          if [ $hooks_created -gt 0 ]; then
            log "Sync job complete - Created $hooks_created hooks"
          fi
        '';
      };
    };

    systemd.timers.knot-sync = {
      description = "Debounce timer for Knot sync";
      timerConfig = {
        OnActiveSec = "10s";
        AccuracySec = "5s";
        RemainAfterElapse = false;
      };
    };

    systemd.paths.knot-sync = {
      description = "Watch for new Knot repositories";
      wantedBy = [ "multi-user.target" ];
      pathConfig = {
        PathModified = cfg.repoDir;
        Unit = "knot-sync.timer";
        MakeDirectory = true;
      };
    };
  };
}
